Anotaçoes pós GO 

comandos uteis 

// gera um modulo chamado meu-modulo
$ go mod init meu-modulo

// cria o binario do go com o nome do modulo do projeto
// usa como referencia as variaveis de ambiente
// GOOS e GOARCH para gerar o binario para 
// o sistema que e arquitura que estao setados nessas variaveis
$ go build 

<!-- ferramenta para mind map, wireframe etc -->
https://whimsical.com/boards
https://excalidraw.com/

<!--  -->

```sql
create table products (id varchar(255), name varchar(80), price decimal (10,2), primary key (id));
```

```go
  // config para set do DB
	cfg := mysql.NewConfig()
	cfg.User = "root"
	cfg.Passwd = "root"
	cfg.Net = "tcp"
	cfg.Addr = "127.0.0.1:3307"
	cfg.DBName = "goexpert"

	// Get a database handle.
	// var err error
	db, err := sql.Open("mysql", cfg.FormatDSN())
```

```sh
$ go mod init github.com/devfullcycle/6/6 && go mod tidy

```

drop table serial_numbers;
drop table products;
drop table categories;


aula 3 do packaging 
 comando 
 go mod edit --replace <module_name>=../<endereco_relativo_na_maquina>

======================================================= 1* Desafio ===========================================================

Olá dev, tudo bem?
 
Neste desafio vamos aplicar o que aprendemos sobre webserver http, contextos,
banco de dados e manipulação de arquivos com Go.
 
Você precisará nos entregar dois sistemas em Go:
- client.go
- server.go
 
Os requisitos para cumprir este desafio são:
 
O client.go deverá realizar uma requisição HTTP no server.go solicitando a cotação do dólar.
 
O server.go deverá consumir a API contendo o câmbio de Dólar e Real no endereço: https://economia.awesomeapi.com.br/json/last/USD-BRL e em seguida deverá retornar no formato JSON o resultado para o cliente.
 
Usando o package "context", o server.go deverá registrar no banco de dados SQLite cada cotação recebida, sendo que o timeout máximo para chamar a API de cotação do dólar deverá ser de 200ms e o timeout máximo para conseguir persistir os dados no banco deverá ser de 10ms.
 
O client.go precisará receber do server.go apenas o valor atual do câmbio (campo "bid" do JSON). Utilizando o package "context", o client.go terá um timeout máximo de 300ms para receber o resultado do server.go.
 
Os 3 contextos deverão retornar erro nos logs caso o tempo de execução seja insuficiente.
 
O client.go terá que salvar a cotação atual em um arquivo "cotacao.txt" no formato: Dólar: {valor}
 
O endpoint necessário gerado pelo server.go para este desafio será: /cotacao e a porta a ser utilizada pelo servidor HTTP será a 8080.
 
Ao finalizar, envie o link do repositório para correção.

==============================================================================================================================


/testing 
	comando
	<!-- da um output da cobertura de teste -->
	$ go test -coverprofile=coverage.out

	<!-- da um output em html de qual treicho nao esta coberto com teste -->
	$ go tool cover -html=coverage.out
	
	<!-- executa testes em benchmark -->
	$ go test -bench=.

	<!-- executa testes de benchmark com paramentros -->
	$ go test -bench=. -run= -count=10 -benchtime=3s -benchmem
	-run= recebe um regex para identificar o teste que vai ser executado
	-count= quantidade de vezes que ele vai executar cada teste
	-benchtime= um tempo de execuçao para cada teste
	-benchmem exibe a memoria alocada em cada teste executado

// fuzzing
	testes de mutaçao
	go test -fuzz=. -fuzztime=5s
	-fuzztime=5s tempo de execuçao desse tipo de teste
================================================================================================================================

fluxo de um Middleware 

Request -> Middleware(usa os dados, faz alguma coisa. Continua)|outro Middleware|outro Middleware -> Handler -> Response

================================================================================================================================

bibliotecas para consultar 
	* https://github.com/swaggo/swag <!-- Swag converts Go annotations to Swagger Documentation -->

============================================ Multithreading ========================================================

compartilhamento de recurso entre threads 
	mais de uma thread usa a mesma variavel em memoria. 
		-> isso acarreta em race condition 
	
	mutex
		-> Mutual exclusion
		method lock 
			-> trava a variavel para nao ser alterada por outra thread 
		method Unlock
			-> libera a variavel para ser alterada por outra thread

	Diferenças entre Concorrencia e Paralelismo
	
	concorrencia e paralelismo
![alt text](conc_parale.png)

	multi core
	cada core é concorrente com suas threads 
	os processos nos outros cores acaba sendo paralelo
	setar mais de um core em go 'ativa' o paralelismo
![alt text](multi_core.png)

	multithreading
	1. cada chamada gera um custo
	1.1 O Syscall para o SO disponibilizar a thread 
	1.2 A thread gerada aloca um espaço inicial de 1mb na ram que tbm gera custo
	1.3 Mudancas de contextos entre cada thread dentro do mesmo processo tambem geram custo.  
![alt text](image.png)

	Schedulers

	* Schedulers resolvem o problema de custo por alocação de recurso para os processos. 
	Dois tipos de schedulers 
	1. Preemptivo
		Determina um tempo por cada tarefa
		pros/contras
		+ as tarefas tendem a finalizar mesmo que o scheduler tire ela de excuçao para outra assumir. 
		- maior tempo de interrupçao entre parar uma tarefa e outra assumir
	2. Cooperativo
		Espera uma tarefa terminar para começar outra.
		pros/contras
		+ menor tempo e interrupção
			a proxima só assume quando a anterior finalizar.  
		- maior temppo de execuçao se cada tarefa levar um tempo consideravel, o tempo final para as conclusoes das tarefas tbm é maior.

	Threads e Schedulers em GO 
	Go tem seu proprio scheduler (ele nao utiliza em primeira via uma chamada para o scheduler do SO)
	Chamado de 'Gerenciamento de Threads' / 'Green Threads' / 'Threads in Userland' / 'light threads' 
	Scheduler do GO trabalha de forma Cooperativa para evitar mudança frequente de contexto.
	OBS: o Go identifica quando uma tarefa vai executar sem tempo determinado (como em um loop infinito) ele automaticamente muda para um modelo de scheduler Preemptivo para nao impedir o processamento de outras tarefas. 
	Por default o scheduler do runtime do Go aloca 2Kb de ram por thread.


	Threads no GO 
	O func main ja é uma thread de execuçao no GO 
	outro exemplo é o GarbageCollector que tem uma thread exclusiva para ele.

	Wait Groups
	* Adiciona quantidade de tarefas/operaçoes
	* Informar que foi finalizada uma operaçao
	* Esperar até que as operações sejam finalizadas.

	Go command 
	<!-- adiciona um inspect na execuçao do projeto e retorna se existe algum bloco ou variavel sofrendo race condition  -->
	go run -race main.go 

	Operaçao atomica 
	Operaçoes atomicas normalmente ja resolvem casos de race conditions em variaveis. 
	pacote sync/atomic ja faz parte dos pacotes defaults do Go. 
	por de baixo dos panos ele faz um lock e unlock da variavel passada no parametro